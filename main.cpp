#include "pico/stdlib.h"#include "BME280.h"#include "sx1276.h"#include "ICM20948.h"#include "cstdio"#include "interrupt.h"#include "m100Mini.h"GPS::M100Mini gps = GPS::M100Mini(uart1, 8, 9, 115200);int main(){  stdio_init_all();  gpio_init(26);  gpio_set_dir(26, GPIO_OUT);  gpio_put(26, true);  GPS::NAV_POSLLH gpsData{};  while(true){    gps.GetGPS(&gpsData);    printf("Header: %d\nClass: %d\nID: %d\nLen:%d\niTow: %lu ms\nlon: %f deg\nlat: %f deg\nheight: %ld mm\n\n\n",gpsData.header, gpsData.cls, gpsData.id, gpsData.len, gpsData.iTOW, gpsData.lon * 1e-7, gpsData.lat * 1e-7, gpsData.height);    busy_wait_ms(500);  }}//#include "pico/stdlib.h"//#include "cstdio"//#include "hardware/uart.h"//#include "hardware/dma.h"////// Определяем параметры UART//#define UART_ID uart1//#define BAUD_RATE 115200//#define DATA_BITS 8//#define STOP_BITS 1//#define PARITY    UART_PARITY_NONE////// Пины UART//#define UART_TX_PIN 8//#define UART_RX_PIN 9////void uart_init() {//  uart_init(UART_ID, BAUD_RATE);//  uart_set_hw_flow(UART_ID, false, false);////  uart_set_format(UART_ID, DATA_BITS, STOP_BITS, PARITY);//  uart_set_fifo_enabled(UART_ID, false);////  gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);//  gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);//}////#define BUFFER_SIZE 36////static uint8_t rx_buffer[BUFFER_SIZE];//static volatile uint32_t write_index = 0;////void dma_handler() {//  // Получаем номер канала, вызвавшего прерывание//  int channel = dma_hw->ints0;//  dma_hw->ints0 = channel; // Сбрасываем флаг прерывания////  // Обновляем индекс записи в буфере//  write_index = (write_index + BUFFER_SIZE) % BUFFER_SIZE;////  // Перезапускаем DMA для дальнейшего чтения//  dma_channel_set_read_addr(channel, &uart_get_hw(UART_ID)->dr, true);//}////void dma_uart_init() {//  // Настраиваем DMA канал для RX//  int dma_chan = dma_claim_unused_channel(true);//  dma_channel_config c = dma_channel_get_default_config(dma_chan);////  // Конфигурация канала DMA для работы с UART RX//  channel_config_set_transfer_data_size(&c, DMA_SIZE_8);//  channel_config_set_read_increment(&c, false);//  channel_config_set_write_increment(&c, true);//  channel_config_set_ring(&c, true, 6);  // Циклический буфер 36 байт (2^6 = 64, использовать только 36)////  dma_channel_configure(//      dma_chan,//      &c,//      rx_buffer,               // Куда записывать данные//      &uart_get_hw(UART_ID)->dr, // Откуда читать данные//      BUFFER_SIZE,             // Количество байт для передачи//      true                     // Начинаем сразу после настройки//  );////  // Включаем прерывание DMA при завершении передачи//  dma_channel_set_irq0_enabled(dma_chan, true);////  irq_set_exclusive_handler(DMA_IRQ_0, dma_handler);//  irq_set_enabled(DMA_IRQ_0, true);//}////////void process_uart_data() {//  static uint32_t read_index = 0;////  while (read_index != write_index) {//    uint8_t data = rx_buffer[read_index];//    read_index = (read_index + 1) % BUFFER_SIZE;////    // Обработка полученных данных//    // Например, вывод на консоль//    printf("Received: %c\n", data);//  }//}////int main() {//  stdio_init_all();//  uart_init();//  dma_uart_init();////  while (true) {//    process_uart_data();//    tight_loop_contents();//  }////  return 0;//}