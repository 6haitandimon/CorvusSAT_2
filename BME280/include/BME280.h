#pragma once#include "pico/stdlib.h"#include "hardware/i2c.h"//#include "pico/mutex.h"#include "BME280Reg.h"#include "cstdio"#include "math.h"namespace BME{struct BME280Data{  float temp;  float press;  float hum;}__packed;class BME280{private:  /**************************************************************************/  /*!      @brief  sampling rates  */  /**************************************************************************/  enum sensor_sampling {    SAMPLING_NONE = 0b000,    SAMPLING_X1 = 0b001,    SAMPLING_X2 = 0b010,    SAMPLING_X4 = 0b011,    SAMPLING_X8 = 0b100,    SAMPLING_X16 = 0b101  };  /**************************************************************************/  /*!      @brief  power modes  */  /**************************************************************************/  enum sensor_mode {    MODE_SLEEP = 0b00,    MODE_FORCED = 0b01,    MODE_NORMAL = 0b11  };  /**************************************************************************/  /*!      @brief  filter values  */  /**************************************************************************/  enum sensor_filter {    FILTER_OFF = 0b000,    FILTER_X2 = 0b001,    FILTER_X4 = 0b010,    FILTER_X8 = 0b011,    FILTER_X16 = 0b100  };  /**************************************************************************/  /*!      @brief  standby duration in ms  */  /**************************************************************************/  enum standby_duration {    STANDBY_MS_0_5 = 0b000,    STANDBY_MS_10 = 0b110,    STANDBY_MS_20 = 0b111,    STANDBY_MS_62_5 = 0b001,    STANDBY_MS_125 = 0b010,    STANDBY_MS_250 = 0b011,    STANDBY_MS_500 = 0b100,    STANDBY_MS_1000 = 0b101  };//  mutex_t i2c_mutex;  i2c_inst_t * i2c;  uint8_t i2cAddr;  uint8_t sda;  uint8_t scl;  uint8_t configVal;  uint8_t ctrl_hum;  uint8_t ctrl_maes;  int32_t t_fine;  struct bmp280_calib_param {    uint16_t dig_T1; ///< temperature compensation value    int16_t dig_T2;  ///< temperature compensation value    int16_t dig_T3;  ///< temperature compensation value    uint16_t dig_P1; ///< pressure compensation value    int16_t dig_P2;  ///< pressure compensation value    int16_t dig_P3;  ///< pressure compensation value    int16_t dig_P4;  ///< pressure compensation value    int16_t dig_P5;  ///< pressure compensation value    int16_t dig_P6;  ///< pressure compensation value    int16_t dig_P7;  ///< pressure compensation value    int16_t dig_P8;  ///< pressure compensation value    int16_t dig_P9;  ///< pressure compensation value    uint8_t dig_H1; ///< humidity compensation value    int16_t dig_H2; ///< humidity compensation value    uint8_t dig_H3; ///< humidity compensation value    int16_t dig_H4; ///< humidity compensation value    int16_t dig_H5; ///< humidity compensation value    int8_t dig_H6;  ///< humidity compensation value  } ParamCalib;  uint8_t readRegistr8Bit(uint8_t RegAddr);  uint16_t readRegistr16Bit(uint8_t RegAddr);  int16_t readRegistr16Bit_LE(uint8_t RegAddr);  uint32_t readRegistr24Bit(uint8_t RegAddr);  int writeRegistr(uint8_t RegAddr, uint8_t data);  void getCalibData();  int32_t convertData(uint32_t data);public:  BME280(i2c_inst_t *_i2c,  uint8_t _sda, uint8_t _scl, uint8_t _configVal = 0, uint8_t _addr = ADDR);  void setSampling(sensor_mode mode = MODE_NORMAL,                   sensor_sampling tempSampling = SAMPLING_X16,                   sensor_sampling pressSampling = SAMPLING_X16,                   sensor_sampling humSampling = SAMPLING_X16,                   sensor_filter filter = FILTER_OFF,                   standby_duration duration = STANDBY_MS_0_5);  int32_t GetTemp();  uint32_t  GetPressure();  uint32_t GetHumidity();  float GetAltitude(float seeLevel);  void Reset();  void GetAllData(BME280Data* data);  //use only after reset  bool BME280_INIT();  struct config {    // inactive duration (standby time) in normal mode    // 000 = 0.5 ms    // 001 = 62.5 ms    // 010 = 125 ms    // 011 = 250 ms    // 100 = 500 ms    // 101 = 1000 ms    // 110 = 10 ms    // 111 = 20 ms    unsigned int t_sb : 3; ///< inactive duration (standby time) in normal mode    // filter settings    // 000 = filter off    // 001 = 2x filter    // 010 = 4x filter    // 011 = 8x filter    // 100 and above = 16x filter    unsigned int filter : 3; ///< filter settings    // unused - don't set    unsigned int none : 1;     ///< unused - don't set    unsigned int spi3w_en : 1; ///< unused - don't set    /// @return combined config register    unsigned int get() { return (t_sb << 5) | (filter << 2) | spi3w_en; }  };  config _configReg; //!< config register object  /**************************************************************************/  /*!      @brief  ctrl_meas register  */  /**************************************************************************/  struct ctrl_meas {    // temperature oversampling    // 000 = skipped    // 001 = x1    // 010 = x2    // 011 = x4    // 100 = x8    // 101 and above = x16    unsigned int osrs_t : 3; ///< temperature oversampling    // pressure oversampling    // 000 = skipped    // 001 = x1    // 010 = x2    // 011 = x4    // 100 = x8    // 101 and above = x16    unsigned int osrs_p : 3; ///< pressure oversampling    // device mode    // 00       = sleep    // 01 or 10 = forced    // 11       = normal    unsigned int mode : 2; ///< device mode    /// @return combined ctrl register    unsigned int get() { return (osrs_t << 5) | (osrs_p << 2) | mode; }  };  ctrl_meas _measReg; //!< measurement register object  /**************************************************************************/  /*!      @brief  ctrl_hum register  */  /**************************************************************************/  struct ctrl_hum {    /// unused - don't set    unsigned int none : 5;    // pressure oversampling    // 000 = skipped    // 001 = x1    // 010 = x2    // 011 = x4    // 100 = x8    // 101 and above = x16    unsigned int osrs_h : 3; ///< pressure oversampling    /// @return combined ctrl hum register    unsigned int get() { return (osrs_h); }  };  struct ctrl_hum _humReg;};}